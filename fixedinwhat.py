#!/usr/bin/env python3

import requests
import argparse
import json
import csv
from sys import stdout
from tabulate import tabulate


pyxis = "https://catalog.redhat.com/api/containers/v1"
hydra = "https://access.redhat.com/hydra/rest/securitydata"


def main():
    parser = argparse.ArgumentParser(description="A tool to easily show what CVE's have been fixed in images in Red Hat's container image registries")
    parser.add_argument("registry", help="the redhat registry", choices=["registry.access.redhat.com","registry.connect.redhat.com"])
    parser.add_argument("repository", help="the repo for the image, this is can be a single image name or a path ubi8 or ubi8/ubi")
    parser.add_argument("-o", "--output", choices=["csv", "table", "json"], help="output format", default="json")
    parser.add_argument("--since", help="this is an image tag and only this image and newer will be returned, if invalid nothing will be returned")
    parser.add_argument("--arch", help="only look at specific architecture", choices=["amd64", "aarch64", "s390x"])  #TODO add the rest of architectures
    args = parser.parse_args()
    images = image_lookup(args.registry, args.repository, since=args.since, arch=args.arch )
    if args.output == "csv":
        csv_keys = images[0].keys()
        writer = csv.DictWriter(stdout, fieldnames=csv_keys)
        writer.writerows(images)
    elif args.output == "table":
        print(tabulate(images))
    else:
        print(json.dumps(images))
        
    

    

def image_lookup(image_registry,image_repo, since=None, arch=None):


    #image_registry = "registry.access.redhat.com"
    #image_repo = "ubi8"
    pyxis_image_url = f"{pyxis}/repositories/registry/{image_registry}/repository/{image_repo}/images"

 

    count = 0
    imagedata = []
    page = 0
    # Get all of the images in pyxis api
    while True:
        pyxis_response = requests.get(f"{pyxis_image_url}?page={page}").json()
        imagedata += pyxis_response["data"]
        count += len(pyxis_response["data"])
        if count == pyxis_response["total"]:
            break
        page +=1


    return_list = []
    seen = False
    for image in imagedata: 
        image_advisory_id = []
        image_tags = []
        content_advisory_ids = []
        if (arch is not None) and (image["architecture"] != arch):
            continue
        for repository in image["repositories"]:
            if "image_advisory_id" in repository.keys():
                image_advisory_id.append(repository["image_advisory_id"])
            if "content_advisory_ids" in repository.keys():
                content_advisory_ids += repository["content_advisory_ids"]
            for tags in repository["tags"]:
                if tags["name"] == "latest":
                    continue
                if (not seen) and (since is not None) and tags["name"] == since:
                    seen = True
                image_tags.append(tags["name"])

        
        # This makes the assumption that the api returns oldest to newest
        # Logic for "since"
        if (not seen) and (since is not None):
            continue

        this_image = {
            "image": f"""{image_registry}/{image_repo}""",
            "tag": max(set(image_tags), key=len),
            "image_advisory": list(set(image_advisory_id)),
            "content_advisory": list(set(content_advisory_ids)),
            "fixed_cves": []
        }

        for advisory in (this_image["content_advisory"] + this_image["image_advisory"]):
            # Only need to look at RHSA
            # Per Red Hat CVEs are not included in RHBA or RHEA
            # https://access.redhat.com/articles/explaining_redhat_errata
            if "RHSA"  in advisory:
                this_image["fixed_cves"] += list(get_cve_from_rhsa(advisory))

        return_list.append(this_image)

    return return_list

def get_cve_from_rhsa(rhsa):
    hydra_response = requests.get(f"{hydra}/csaf/{rhsa}.json").json()
    if "vulnerabilities" in hydra_response.keys():
                for vuln in hydra_response["vulnerabilities"]:
                    yield vuln["cve"]


if __name__ == "__main__":
    main()
