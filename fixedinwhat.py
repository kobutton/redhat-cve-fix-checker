#!/usr/bin/env python3

import grequests
import argparse
import json
import csv
from sys import stdout
from tabulate import tabulate


pyxis = "https://catalog.redhat.com/api/containers/v1"
hydra = "https://access.redhat.com/hydra/rest/securitydata"


def main():
    parser = argparse.ArgumentParser(description="A tool to easily show what CVE's have been fixed in images in Red Hat's container image registries")
    parser.add_argument("registry", help="the redhat registry", choices=["registry.access.redhat.com","registry.connect.redhat.com"])
    parser.add_argument("repository", help="the repo for the image, this is can be a single image name or a path ubi8 or ubi8/ubi")
    parser.add_argument("-o", "--output", choices=["csv", "table", "json"], help="output format", default="json")
    parser.add_argument("--since", help="this is an image tag and only this image and newer will be returned, if invalid nothing will be returned")
    parser.add_argument("--arch", help="only look at specific architecture", choices=["amd64", "aarch64", "s390x"])  #TODO add the rest of architectures
    args = parser.parse_args()
    images = image_lookup(args.registry, args.repository, since=args.since, arch=args.arch)
    if args.output == "csv":
        csv_keys = images[0].keys()
        writer = csv.DictWriter(stdout, fieldnames=csv_keys)
        writer.writerows(images)
    elif args.output == "table":
        print(tabulate(images))
    else:
        print(json.dumps(images))
        
    

    

def image_lookup(image_registry,image_repo, since=None, arch=None):


    #image_registry = "registry.access.redhat.com"
    #image_repo = "ubi8"
    pyxis_image_url = f"{pyxis}/repositories/registry/{image_registry}/repository/{image_repo}/images"

    imagedata = []
    count = 0
    # Get all of the images in pyxis api
    pyxis_response = grequests.map([grequests.get(f"{pyxis_image_url}")])[0].json()
    imagedata += pyxis_response["data"]
    count += len(pyxis_response["data"])
    total = pyxis_response["total"]

    total_pages = (total + count - 1) // count
    pyxis_responses = map(lambda response: response.json(), grequests.map(map(lambda page: grequests.get(f"{pyxis_image_url}?page={page}"), range(1, total_pages))))
    for pyxis_response in pyxis_responses:
        imagedata += pyxis_response["data"]
        count += len(pyxis_response["data"])

    advisory_set = set()
    return_list = []
    seen = False
    for image in imagedata: 
        image_advisory_id = []
        image_tags = []
        content_advisory_ids = []
        if (arch is not None) and (image["architecture"] != arch):
            continue
        for repository in image["repositories"]:
            if "image_advisory_id" in repository.keys():
                image_advisory_id.append(repository["image_advisory_id"])
            if "content_advisory_ids" in repository.keys():
                content_advisory_ids += repository["content_advisory_ids"]
            for tags in repository["tags"]:
                if tags["name"] == "latest":
                    continue
                if (not seen) and (since is not None) and tags["name"] == since:
                    seen = True
                image_tags.append(tags["name"])

        
        # This makes the assumption that the api returns oldest to newest
        # Logic for "since"
        if (not seen) and (since is not None):
            continue

        this_image = {
            "image": f"""{image_registry}/{image_repo}""",
            "tag": max(set(image_tags), key=len),
            "image_advisory": list(set(image_advisory_id)),
            "content_advisory": list(set(content_advisory_ids)),
            "fixed_cves": []
        }
        advisory_set.update(this_image["content_advisory"])
        advisory_set.update(this_image["image_advisory"])
        return_list.append(this_image)

    # Only need to look at RHSA
    # Per Red Hat CVEs are not included in RHBA or RHEA
    # https://access.redhat.com/articles/explaining_redhat_errata
    advisory_list = list(filter(lambda advisory: "RHSA" in advisory, advisory_set))
    hydra_responses = list(map(lambda hydra_response: hydra_response.json(), grequests.map((grequests.get(f"{hydra}/csaf/{advisory}.json") for advisory in advisory_list))))
    advisory_dict = {}

    for i in range(len(advisory_list)):
        advisory_dict[advisory_list[i]] = hydra_responses[i]

    for this_image in return_list:
        for advisory in (this_image["content_advisory"] + this_image["image_advisory"]):
            this_image["fixed_cves"] += list(get_cve_from_hydra_response(advisory_dict.get(advisory)))

    return return_list

def get_cve_from_hydra_response(hydra_response):
    if hydra_response is not None and "vulnerabilities" in hydra_response.keys():
        for vuln in hydra_response["vulnerabilities"]:
            yield vuln["cve"]


if __name__ == "__main__":
    main()
